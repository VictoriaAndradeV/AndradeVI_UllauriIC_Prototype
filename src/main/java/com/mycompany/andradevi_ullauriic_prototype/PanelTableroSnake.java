package com.mycompany.andradevi_ullauriic_prototype;

import java.awt.Color;
import java.awt.Graphics;
import javax.swing.JPanel;
import java.awt.Dimension;
import java.util.ArrayList;
import prototipo.ElementoBase;

public class PanelTableroSnake extends JPanel {
    
    private final int filas = 20;
    private final int columnas = 20;
    private final int tamanioCelda = 25;
    
    private ArrayList<ElementoBase> elementos = new ArrayList<>();
    
    public PanelTableroSnake() {
        initComponents();
        setFocusable(true); //recibe el foco de teclado
        setFocusTraversalKeysEnabled(false); //evita que las flechas muevan el foco entre controles
    }
    
    public void setElementos(ArrayList<ElementoBase> elementos){
        this.elementos = elementos;
        repaint();
    }
    
    public ArrayList<ElementoBase> getElementos() {
        return elementos;
    }
    
    @Override
    protected void paintComponent(Graphics g){
        super.paintComponent(g);
        
        g.setColor(Color.WHITE);
        
        //        (0,0 posicion horizontal y vertical en donde empieza a pintar
        //        getWidth(), getHeight() es para saber el tamanio de los pixeles 
        g.fillRect(0, 0, getWidth(), getHeight());
        
        g.setColor(Color.LIGHT_GRAY);
                        
        //lineas verticales de cuadricula
        for(int i = 0; i <= columnas; i++){
            int x = i * tamanioCelda;
            //g.drawLine(x1, y1, x2, y2) 
            //1 es para puntos iniciales 
            //2 puntos finales, hasta donde debe trazar las lineas
            g.drawLine(x, 0, x, filas*tamanioCelda);
        }
        
        //lineas horizontales
        for(int j = 0; j <= filas; j++){
            int y = j * tamanioCelda;
            g.drawLine(0, y, columnas * tamanioCelda, y);
        }
        
         // Dibujar elementos
        if (elementos != null) {
            for (ElementoBase e : elementos) {
                e.dibujar(g);
            }
        }
    }
    
    public void colocarElementoCelda(ElementoBase elemento, int x, int y){
        int pixelX = x * tamanioCelda + (tamanioCelda / 2) - (elemento.getTamanio() / 2);
        int pixelY = y * tamanioCelda + (tamanioCelda / 2) - (elemento.getTamanio() / 2);
        elemento.setX(pixelX);
        elemento.setY(pixelY);
    }
    
    //metodos que obtienen la celda de un elemento
    public int getCeldaElementoX(prototipo.ElementoBase e){
        return (e.getX() - (tamanioCelda - e.getTamanio()) / 2)/tamanioCelda;
    }
    
    public int getCeldaElementoY(prototipo.ElementoBase e){
        return (e.getY() - (tamanioCelda - e.getTamanio()) / 2)/tamanioCelda;
    }
    
    //validacion para actualizar la posicion de la comida
    //validar si la celda no esta ocupada 
    public boolean celdaOcupada(int x, int y, ElementoBase ignorar){
        if((x < 0 || (x >= columnas) || (y < 0)|| (y >= filas))){
            return true;
        }
        
        for(ElementoBase e: elementos){
            if(e != null && e != ignorar){
                int eX = x * tamanioCelda + (tamanioCelda - e.getTamanio()) / 2;
                int eY = y * tamanioCelda + (tamanioCelda - e.getTamanio()) / 2;
                
                if (e.getX() == eX && e.getY() == eY) {
                    return true; //existe un objeto en la celda
                }
            }
        }
        return false;
    }
    //metodo que nos permite colocar el clon debajo de la celda libre
    //debajo de la base
    public int[] celdaLibreBase(int baseX, int baseY){
        int busqMax = 20*20; //busca los espacios libres debajo de la base
        int celda1 = 1;
        
        //buscamos debajo de la bse
        for(int y = baseY + 1; y < filas; y++){
            if(!celdaOcupada(baseX, y, null)){
                return new int[] {baseX,y};
            }
        }
        
        //columnas a la derecha
        for(int x = baseX + 1; x < columnas; x++){
            for (int y = 0; y < filas; y++) {
                if (!celdaOcupada(x, y, null)) {
                    return new int[] { x, y };
                }
            }
        }
        return null;
    }
    
    @Override
    public Dimension getPreferredSize(){
        return new Dimension(columnas*tamanioCelda, filas*tamanioCelda);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 484, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 362, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
    
    //-------------------------------------------------
    // Elimina un elemento del tablero
    public void eliminarElemento(ElementoBase e) {
        //si no existe, no hace nada
        if (e == null) {
            return;
        }
        // quita de la lista de elementos que se dibujan
        elementos.remove(e);
    }

    // Busca un elemento en una celda especifica del tablero
    public ElementoBase getElementoEnCelda(int celdaX, int celdaY, String tipoEsperado) {
        for (ElementoBase e : elementos) {
            //calcula la celda del elemento
            int ex = getCeldaElementoX(e);
            int ey = getCeldaElementoY(e);

            //y esta justo en la celda que buscamos
            if (ex == celdaX && ey == celdaY) {
                //y si el tipo coincide , devuelve
                if (tipoEsperado == null || tipoEsperado.equals(e.getTipoElemento())) {
                    return e;
                }
            }
        }
        return null;
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
